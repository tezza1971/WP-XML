<?php
/**
 * Xao_Util_DbToXml.php
 * 
 * This script is pivotal to developers who wish to retrieve content from a
 * relational database. It's primary function is to convert tabular results sets
 * to XML format. It does more than that however, see the class doc comments and
 * tutorials for information on how to leverage it's awsome power.
 *
 * @author       Terence Kearns
 * @version      1.0 alpha
 * @copyright    Terence Kearns 2003
 * @license      LGPL
 * @package      XAO
 * @link         http://xao-php.sourceforge.net
 */

/**
 * Convert a result table from an SQL query into basic XML.
 *
 * Very simple conversion of SQL query results table to XML data which may then
 * be transformed into a suitable structure. See the <b>basics/dbAccess></b>
 * tutorial for more information on usage. Optionally more complext usage can
 * include the use of callback functions through the optional arguments to the
 * constructor. See the constructor method documentation for details. This class
 * extends the DomDoc content class and therefore inherits all DomDoc
 * capabilities. You'll probably use the data generated by this class by way of
 * the ndConsumeDoc() method on your AppDoc based instance.
 *
 * @package      XAO
 */
class   Xao_Util_DbToXml 
extends Xao_DomDoc 
{
    /**
     * 
     */
    private $_blnEncoded = false;
    
    /**
     * The stub node onto which the result nodes will be grafted.
     * 
     * This is specified in the constructor (if used) where it is employed by
     * the execute() method as the place to append the row nodes. Unless a stub
     * node is specified in the constructor, it will be assigned the instance
     * $this->ndRoot (the root/result node).
     *
     * @var      node
     * @see      DomDoc::$ndRoot
     */
    public $ndStub;
    
    /**
     * 2D array containing the rows and colums of the result returned from the
     * passed DB result object.
     *
     * @var      object
     */
    public $arrResult              = array();

    /**
     * Field-name/Element-name function mapping.
     *
     * This member is populated by the optional second argument to the
     * constructor function. It is an associative array with a list of columns
     * (the array keys) and their associated handlers/call-back-functions (the
     * array values).
     *
     * @var      array
     */
    public $arrDbCallBacks;
    
    public $blnCheckSplice = false;
    private $blnSpliceOk = false;
    public $arrSplicedKeys = array();
    
    /**
     * List of columns which the result tree is to be grouped into
     * 
     * This is an ordered array of column names which are to be used to group
     * (nest) the XML output element. This class attribute is populated by an
     * argument to the $this->GroupBy() method.
     *
     * @var      array
     */
    public $arrGroupByCols = array();
    
    /**
     * flag to ensure the missing callback method exception is only thrown once
     *
     * @var      boolean
     */
    public $blnThrewFuncXcptn = false;
    
    /**
     * Constructor method
     *Perform requirements checks and initialised resources.
     *
     * @param   object  An instance of a PEAR DB result object or a
     *                  associative  array.
     * @param   string  The name of the element to which the results r attached
     * @param   array   An associative array mapping result column names to
     *                  methods (call back functions) of the class.
     * @param   object  a DOM node in the referenced document where the results
     * from   this calss will be appended.
     * @return   void
     */
    
    public function __construct(
        $mxdResult,
        $strResultName  = "results",
        $arrCallBacks   = array(),
        $ndStub         = null
    ) {
        $this->SetCallBacks($arrCallBacks);
        $this->SetResultTagName($strResultName);
        $this->setStub($ndStub);
                                        // if applicable, populate the 2d 
                                        // associative array that will be used 
                                        // to build our XML
        if(is_array($mxdResult)) {
            $this->arrResult = $mxdResult;
        }
        elseif(!is_array($mxdResult)) {
            $mxdResult = array();
            $this->arrResult = $mxdResult;
        }
                                        // throw an error if the param is 
                                        // neither an array or valid result obj
        else {
            $this->XaoThrow(
                "DbToXml: Constructor expects a 2D array (or a supported result 
                object).",
                debug_backtrace()
            );
        }
    }
    
    public function AttachTo($ndStub = null) {
        if(is_object($ndStub)) $this->SetStub($ndStub);
        if(is_object($this->objDoc)) $this->XaoThrow(
            "Cannot re-assign node to attach to once DOM document is initiated."
        );
        parent::__construct($this->strRowEl);
                                        // if the stub is not set, then this
                                        // document will be stand-alone. If
                                        // aggregation is involved, one of the
                                        // consume methods will need to be
                                        // manually invoked.
        if(!is_object($this->ndStub)) $this->SetStub($this->ndRoot);
    }
    
    function SetStub($ndStub) {
        $this->ndStub = $ndStub;
    }
    
    public function SetCallBacks($arrCallBacks) {
        if(!is_array($this->arrDbCallBacks)) $this->arrDbCallBacks = array();
        if(
            !count($this->arrDbCallBacks) 
            && (is_array($arrCallBacks) && count($arrCallBacks))
        ) {
            $this->arrDbCallBacks = $arrCallBacks;
            return;
        }
        elseif(is_array($arrCallBacks) && count($arrCallBacks)) {
            $this->arrDbCallBacks = 
                array_merge($this->arrDbCallBacks,$arrCallBacks);
            return;
        }
        
    }
    
    /**
     * Set the name for the results tag.
     *
     * @param    string  Name to use for the root result tag
     * @return   void
     */
    public function SetResultTagName($strName) {
        if($this->_blnEncoded) {
            $this->XaoThrow(
                "DbToXml:_SetResultTagName() Cannot set name once Encoded.",
                debug_backtrace()
            );
            return;
        }
        if($this->blnTestSafeName($strName)) {
            $this->SetRowTagName($strName);
        }
        else {
            $this->XaoThrow(
                "DbToXml::_SetResultTagName() "
                .$strName." is not a valid name for an XML tag.",
                debug_backtrace()
            );
            return;
        }
        
    }

    /**
     * Convert the RDBMS data into XML elements.
     *
     * Iterate over $this->arrResult to first obtain the rows and then the
     * fields which are created and appended as elements using DOM XML methods.
     *
     * @return   void
     * @access   public
     */
    public function Encode() {
        $this->AttachTo();
        if(!count($this->arrResult)) return;
        if(!$this->blnDataIsGood()) return;
                                        // iterate through the result list
        foreach($this->arrResult AS $arrRow) {
            if(!count($arrRow)) continue;
                                        // add a row element for each row in the 
                                        // result list
            $this->ndHashToXml(
                $this->ndStub,
                $arrRow,
                $this->strRowEl,
                $this->arrDbCallBacks
            );
        }
        $this->_blnEncoded = true;
    }
    
    protected function blnDataIsGood() {
        if(!is_array($this->arrResult)) {
            $this->XaoThrow(
                "DbToXml: For some reason, the result set is not formatted 
                [as an] array.",
                debug_backtrace()
            );
            return false;
        }
        
        if(is_object($this->ndStub)) {
            if(!$this->blnTestElementNode($this->ndStub)) {
                $this->XaoThrow(
                    "DbToXml: The stub node is not a valid domelement.",
                    debug_backtrace()
                );
                return false;
            }
        }
        return true;
    }
    
    /**
     * Group records in the output tree by element corresponding to column.
     * 
     * This is a very handy way to quickly group output elements by a selected
     * element. This method is not implemented yet.
     *
     * @param    mixed column(s) to use for grouping
     */
    public function GroupBy($mxdCols) {
        if(is_array($mxdCols))  $this->arrGroupByCols = $mxdCols;
        if(is_string($mxdCols)) $this->arrGroupByCols[] = $mxdCols;
        // not implemented yet
    }
    
    /**
     * Clean up function to flush existing data.
     * 
     * Calling this function is needed if the constructor is to be called more
     * than once.
     *
     * @return   void
     */
    public function Reset() {
        $this->arrDbCallBacks=null;
        $this->arrResult=array();
        $this->ndStub=null;
        // now the constructor will need to be called again before this
        // object instance can be used further.
    }

    /**
     * Row Contructor
     * 
     * This abstract method may be overridden by the child class in order to
     * perform an operation just _prior_ to the execution of a row in the
     * execute() method of this class
     *
     * @param    node    a reference to the element node representing a row
     * @access   public
     * @return   void
     */
    public function RowConstructor($ndRow){}

    /**
     * Row Destructor
     * 
     * This abstract method may be overridden by the child class in order to
     * perform an operation just _after_ the execution of a row in the execute()
     * method of this class
     *
     * @param    node    a reference to the element node representing a row
     * @access   public
     * @return   void
     */
    public function RowDestructor($ndRow){}
    
    /**
     * Record splicer
     * 
     * This method allows one to augment an XML element with records from a 2d
     * array result set.
     *
     * @param    node    a reference to the element node for attachment
     * @param    arr     a reference to the complete result set for searching
     * @param    string  the name of the column in the result set to match on
     * @param    string  the name to use for the new container element
     * @param    mixed   the value of the trunk key which is to be matched on
     * @param    string  name of a callback function to do further processing
     * @param    string  Array of callback functions for columns
     * @return   void
     */
    public function Splice(
        $ndStub,
        $arrNew,
        $strNewColName,
        $strNodeName,
        $mxdKey,
        $fncCallBack = null,
        $arrCallBacks = array()
    ) {
        foreach($arrNew AS $arrRow) {
            if($arrRow[$strNewColName] == $mxdKey) {
                $ndNew = 
                    $this->ndHashToXml(
                        $ndStub,$arrRow,$strNodeName,$arrCallBacks
                    );
                if(method_exists($this,$fncCallBack)) 
                    $this->$fncCallBack($ndNew);
            }
        }
    }
    
    public function SpliceNameValuePairs(
        $ndStub,
        $arrNew,
        $strNewColName,
        $strNodeName,
        $mxdKey,
        $fncCallBack = null,
        $arrCallBacks = array()
    ) {
        $ndAttribs = $this->ndAppendToNode($ndStub,$strNodeName);
        foreach($arrNew AS $arrAttrib) {
            if($arrAttrib[$strNewColName] == $mxdKey) {
                if($arrAttrib["DATATYPE"] == "lst") {
                    $ndList = $this->ndAppendToNode(
                        $ndAttribs,$arrAttrib["CAPTION"]
                    );
                    $arrList = explode(",",$arrAttrib["VALUE"]);
                    foreach($arrList AS $strItem) {
                        $this->ndAppendToNode($ndList,"Item",$strItem);
                    }
                }
                else {
                    $this->ndAppendToNode(
                        $ndAttribs,$arrAttrib["CAPTION"],$arrAttrib["VALUE"]
                    );
                }
            }
        }
    }
    
    protected function CheckSplice(&$arrNew,$strNewColName) {
        $this->blnCheckSplice = true;
        $this->blnSpliceOk = true;
        if(!is_array($arrNew)) {
            $this->XaoThrow(
                "The Splice function requires an array as it's second " .
                "argument.",
                debug_backtrace()
            );
            $this->blnSpliceOk = false;
            return;
        }
        if(!count($arrNew)) {
            $this->blnSpliceOk = false;
            return;
        }
        if(!is_array($arrNew[0])) {
            $this->XaoThrow(
                "The Splice function requires a 2 dimensional array.",
                debug_backtrace()
            );
            $this->blnSpliceOk = false;
            return;
        }
        if(!array_key_exists($strNewColName,$arrNew[0])) {
            $this->XaoThrow(
                "The Splice function can't find the $strNewColName column " .
                "in the array data.",
                debug_backtrace()
            );
            $this->blnSpliceOk = false;
            return;
        }
    }
    
    protected function ToResultAtt(&$ndField,$strVal) {
        $ndResult = $ndField->parentNode->parentNode;
        $ndResult->setAttribute($ndField->nodeName,$strVal);
        $ndField->parentNode->removeChild($ndField);
    }
}

